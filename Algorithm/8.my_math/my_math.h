//
// Created by 13524 on 2021/2/10.
//

#ifndef LEETCODE_MY_MATH_H
#define LEETCODE_MY_MATH_H
#include "../../Helper.h"
class MyMath{

    inline int findKthLargest(vector<int>& nums, const int k, const int LOW = 0, int high = -1 /* 实际上是size */) {//左闭右开
        //使用某种nb的算法, [bfprt]
        const int HIGH = high == -1 ? (int)nums.size() : high;
        assert(HIGH - LOW >= k);
        if(HIGH - LOW == 1){
            return nums[LOW];
        }
        vector<int> middles;
        //cout<<"low="<<LOW<<'\t'<<"high="<<HIGH<<'\t'<<"K="<<k<<endl;
        for(int i = LOW, j = LOW + 5; ; i = j, j += 5){
            if(j >= HIGH){
                sort(&nums[i], &nums[HIGH]);
                middles.push_back(nums[(i + HIGH - 1) / 2]);
                break;
            }
            else{
                sort(&nums[i], &nums[j]);
                middles.push_back(nums[i+2]);
            }
        }

        const int middle = findKthLargest(middles, ((int)middles.size()+1)/2);  // 原因: k 是从 1 开始计数的...
        int empty_ptr = -1;
        for(int i = LOW;i<HIGH;i++){
            if(nums.at(i) == middle){
                empty_ptr = HIGH - 1;
                swap(nums[i], nums[empty_ptr]);//为了简化流程，引入冗余的move
                break;
            }
        }
        assert(empty_ptr > 0);
        //直到这里，才求出了中间数及其对应的位置


        for(int i = LOW, j = HIGH-1; ;){
            while(i<=j && nums.at(i) >= middle){        // buggy  是以中位数为分隔基准
                i++;
            }
            if(i<j){
                nums[empty_ptr] = nums[i];
                empty_ptr = i;
            } else{
                break;
            }

            while(i<=j && nums.at(j) <= middle) {
                j--;
            }
            if(i<j){
                nums[empty_ptr] = nums[j];
                empty_ptr = j;
            } else{
                break;
            }

        }
        nums[empty_ptr] = middle;


        if(empty_ptr+1 - LOW < k){                                           // buggy  要 +1 -LOW, 因为它才是真正的序数
            return findKthLargest(nums, k-(empty_ptr+1 - LOW), empty_ptr+1, HIGH);
        } else if(empty_ptr+1 - LOW > k){
            return findKthLargest(nums, k, LOW, empty_ptr);
        } else{
            return middle;
        }

    }


    int countPrimes(const int N) {    // 筛法求质数
        bool* const isPrime = new bool [N];
        int cnt = 0;
        for(int i = 2; i < N; i++) isPrime[i] = true;
        for(int i = 2; i < N; i++){
            if(isPrime[i]){
                ++cnt;
                //  buggy N 达到了 5*10^6 , 需要longlong了
                for(long long j = ((long long )i)*i; j<N; j+=i){  // j=i*i 而不是 2*i,  提高效率
                    isPrime[j] = false;
                }
            }
        }
        return cnt;
    }


    //求中位数的一段代码，适用于原数组被打乱，平均复杂度为线性;不适用于数组已经排好序、反序、大量重复元素，因为这样会导致最坏 O(n^2).
    int majorityElement01(vector<int>& nums, int LOW = 0, int HIGH = -1) {
        if(HIGH == -1){
            HIGH = (int)nums.size() - 1;
        }
        if(LOW >= HIGH){
            return nums.at(LOW);
        }
        int middlePtr;
        for(int left = LOW, right = HIGH;;){
            while (left < right && nums.at(left) <= nums.at(right)){
                ++left;
            }
            if(left < right){
                swap(nums[left], nums[right]);
            }
            else{
                middlePtr = left;
                break;
            }
            while (left < right && nums.at(left) <= nums.at(right)){
                --right;
            }
            if(left < right){
                swap(nums[left], nums[right]);
            }
            else{
                middlePtr = left;
                break;
            }
        }
        if(middlePtr > nums.size()/2){
            return majorityElement01(nums, LOW, middlePtr-1);
        }
        else if(middlePtr < nums.size()/2){
            return majorityElement01(nums, middlePtr+1, HIGH);
        } else{
            return nums.at(middlePtr);
        }
    }

    int majorityElement02(vector<int>& nums){
        return findKthLargest(nums,1+(int)nums.size()/2);
    }

    // Boyer-Moore Majority Vote Algorithm
    int majorityElement(vector<int>& nums){
        int count = 0, major;
        for(const int num : nums){
            if(count == 0)
                major = num;
            major == num ? count++: count--;
        }
        return major;
    }

    int maximumProduct(vector<int>& nums) {
        int min1 = INT_MAX, min2 = INT_MAX;
        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;
        for (const int x: nums) {
            if (x < min1) {
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                min2 = x;
            }

            if (x > max1) {
                max3 = max2;
                max2 = max1;
                max1 = x;
            } else if (x > max2) {
                max3 = max2;
                max2 = x;
            } else if (x > max3) {
                max3 = x;
            }
        }
        if(max1<=0 || min2>=0)return max1*max2*max3;
        return max(min1*min2, max3*max2) * max1;
    }

    vector<int> productExceptSelf(const vector<int>& nums) {
        const int N = nums.size();
        vector<int> result(N,1);
        for(int i = N - 1, tmp = 1 ; i >=0; result[i] *= tmp,tmp *= nums[i], i--);
        for(int i = 0    , tmp = 1 ; i < N; result[i] *= tmp,tmp *= nums[i], i++);
        return result;
    }


    //  寻找最小的移动，实际上是中位数即可。不断删除最大值和最小值，因为里面的差的和是定长
    int minMoves2(vector<int>& nums) {
        const int mid = findKthLargest(nums, int(nums.size())/2+1);
        int result = 0;
        for(const int num: nums){
            result += abs(num - mid);
        }
        return result;
    }

public:
    void test_majorityElement(){
        vector<int> v = {233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333};
        cout<<majorityElement(v);
    }

    void test_productExceptSelf(){
        printVector(productExceptSelf({1,2,3,4}));
    }

    void test_minMoves2(){
        vector<int> v = {1,2,3};
        cout<<minMoves2(v);
    }
};
#endif //LEETCODE_MY_MATH_H
